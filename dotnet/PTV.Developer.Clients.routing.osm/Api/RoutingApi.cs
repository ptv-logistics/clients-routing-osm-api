/*
 * Routing OSM
 *
 * With the Routing OSM service you can calculate routes from a list of waypoints based on open street map data.
 *
 * The version of the OpenAPI document: 1.6
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using PTV.Developer.Clients.routing.osm.Client;
using PTV.Developer.Clients.routing.osm.Model;

namespace PTV.Developer.Clients.routing.osm.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IRoutingApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behavior of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road. (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="options">Routing-relevant options like the polyline format. Use array notation like &#x60;options[polylineFormat]&#x3D;GEO_JSON&#x60; to set options. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RouteResponse</returns>
        RouteResponse CalculateRoute(List<string>? waypoints = default(List<string>?), string? profile = default(string?), Options? options = default(Options?), List<Results>? results = default(List<Results>?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behavior of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road. (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="options">Routing-relevant options like the polyline format. Use array notation like &#x60;options[polylineFormat]&#x3D;GEO_JSON&#x60; to set options. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RouteResponse</returns>
        ApiResponse<RouteResponse> CalculateRouteWithHttpInfo(List<string>? waypoints = default(List<string>?), string? profile = default(string?), Options? options = default(Options?), List<Results>? results = default(List<Results>?), int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IRoutingApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behavior of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road. (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="options">Routing-relevant options like the polyline format. Use array notation like &#x60;options[polylineFormat]&#x3D;GEO_JSON&#x60; to set options. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RouteResponse</returns>
        System.Threading.Tasks.Task<RouteResponse> CalculateRouteAsync(List<string>? waypoints = default(List<string>?), string? profile = default(string?), Options? options = default(Options?), List<Results>? results = default(List<Results>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behavior of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road. (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="options">Routing-relevant options like the polyline format. Use array notation like &#x60;options[polylineFormat]&#x3D;GEO_JSON&#x60; to set options. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RouteResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<RouteResponse>> CalculateRouteWithHttpInfoAsync(List<string>? waypoints = default(List<string>?), string? profile = default(string?), Options? options = default(Options?), List<Results>? results = default(List<Results>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IRoutingApi : IRoutingApiSync, IRoutingApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class RoutingApi : IRoutingApi
    {
        private PTV.Developer.Clients.routing.osm.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="RoutingApi"/> class.
        /// </summary>
        /// <returns></returns>
        public RoutingApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RoutingApi"/> class.
        /// </summary>
        /// <returns></returns>
        public RoutingApi(string basePath)
        {
            this.Configuration = PTV.Developer.Clients.routing.osm.Client.Configuration.MergeConfigurations(
                PTV.Developer.Clients.routing.osm.Client.GlobalConfiguration.Instance,
                new PTV.Developer.Clients.routing.osm.Client.Configuration { BasePath = basePath }
            );
            this.Client = new PTV.Developer.Clients.routing.osm.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new PTV.Developer.Clients.routing.osm.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = PTV.Developer.Clients.routing.osm.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RoutingApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public RoutingApi(PTV.Developer.Clients.routing.osm.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = PTV.Developer.Clients.routing.osm.Client.Configuration.MergeConfigurations(
                PTV.Developer.Clients.routing.osm.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new PTV.Developer.Clients.routing.osm.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new PTV.Developer.Clients.routing.osm.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = PTV.Developer.Clients.routing.osm.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RoutingApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public RoutingApi(PTV.Developer.Clients.routing.osm.Client.ISynchronousClient client, PTV.Developer.Clients.routing.osm.Client.IAsynchronousClient asyncClient, PTV.Developer.Clients.routing.osm.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = PTV.Developer.Clients.routing.osm.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public PTV.Developer.Clients.routing.osm.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public PTV.Developer.Clients.routing.osm.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public PTV.Developer.Clients.routing.osm.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public PTV.Developer.Clients.routing.osm.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        ///  Calculates a route by specifying a list of waypoints.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behavior of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road. (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="options">Routing-relevant options like the polyline format. Use array notation like &#x60;options[polylineFormat]&#x3D;GEO_JSON&#x60; to set options. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RouteResponse</returns>
        public RouteResponse CalculateRoute(List<string>? waypoints = default(List<string>?), string? profile = default(string?), Options? options = default(Options?), List<Results>? results = default(List<Results>?), int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.osm.Client.ApiResponse<RouteResponse> localVarResponse = CalculateRouteWithHttpInfo(waypoints, profile, options, results);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Calculates a route by specifying a list of waypoints.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behavior of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road. (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="options">Routing-relevant options like the polyline format. Use array notation like &#x60;options[polylineFormat]&#x3D;GEO_JSON&#x60; to set options. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RouteResponse</returns>
        public PTV.Developer.Clients.routing.osm.Client.ApiResponse<RouteResponse> CalculateRouteWithHttpInfo(List<string>? waypoints = default(List<string>?), string? profile = default(string?), Options? options = default(Options?), List<Results>? results = default(List<Results>?), int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.osm.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.osm.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (waypoints != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("multi", "waypoints", waypoints));
            }
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            if (options != null)
            {
                if (options.PolylineFormat != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "options[polylineFormat]", options.PolylineFormat));
                }
            }
            if (results != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("csv", "results", results));
            }

            localVarRequestOptions.Operation = "RoutingApi.CalculateRoute";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<RouteResponse>("/routes", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CalculateRoute", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Calculates a route by specifying a list of waypoints.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behavior of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road. (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="options">Routing-relevant options like the polyline format. Use array notation like &#x60;options[polylineFormat]&#x3D;GEO_JSON&#x60; to set options. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RouteResponse</returns>
        public async System.Threading.Tasks.Task<RouteResponse> CalculateRouteAsync(List<string>? waypoints = default(List<string>?), string? profile = default(string?), Options? options = default(Options?), List<Results>? results = default(List<Results>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.routing.osm.Client.ApiResponse<RouteResponse> localVarResponse = await CalculateRouteWithHttpInfoAsync(waypoints, profile, options, results, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Calculates a route by specifying a list of waypoints.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behavior of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road. (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="options">Routing-relevant options like the polyline format. Use array notation like &#x60;options[polylineFormat]&#x3D;GEO_JSON&#x60; to set options. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RouteResponse)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routing.osm.Client.ApiResponse<RouteResponse>> CalculateRouteWithHttpInfoAsync(List<string>? waypoints = default(List<string>?), string? profile = default(string?), Options? options = default(Options?), List<Results>? results = default(List<Results>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            PTV.Developer.Clients.routing.osm.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.osm.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (waypoints != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("multi", "waypoints", waypoints));
            }
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            if (options != null)
            {
                if (options.PolylineFormat != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "options[polylineFormat]", options.PolylineFormat));
                }
            }
            if (results != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("csv", "results", results));
            }

            localVarRequestOptions.Operation = "RoutingApi.CalculateRoute";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<RouteResponse>("/routes", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CalculateRoute", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
