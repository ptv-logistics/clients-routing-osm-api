/*
 * Routing OSM
 *
 * With the Routing OSM service you can calculate routes from a list of waypoints based on open street map data.
 *
 * The version of the OpenAPI document: 1.6
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using PTV.Developer.Clients.routing.osm.Client;
using PTV.Developer.Clients.routing.osm.Model;

namespace PTV.Developer.Clients.routing.osm.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReachableAreasApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons.</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[drivingDirection]&#x3D;OUTBOUND&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreas</returns>
        ReachableAreas CalculateReachableAreas(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons.</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[drivingDirection]&#x3D;OUTBOUND&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreas</returns>
        ApiResponse<ReachableAreas> CalculateReachableAreasWithHttpInfo(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of a reachable areas calculation.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void DeleteReachableAreas(Guid? id, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of a reachable areas calculation.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteReachableAreasWithHttpInfo(Guid? id, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable areas calculation specified by its ID.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of a reachable areas calculation.</param>
        /// <param name="maximumPollingPeriod">If the calculation is still running, this operation will be blocked and will not return before this period [ms] expires. If the calculation is completed, it will return immediately.  The default of 0 ms will cause the operation to return immediately in any case. Use a value &gt; 0 to implement long polling to reduce the number of requests. See the [tutorial](https://developer.myptv.com/en/resources/tutorials/general/how-use-asynchronous-requests-ptv-developer-apis) on asynchronous requests for details.  (optional, default to 0)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreasResponse</returns>
        ReachableAreasResponse GetReachableAreas(Guid? id, int? maximumPollingPeriod = default(int?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable areas calculation specified by its ID.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of a reachable areas calculation.</param>
        /// <param name="maximumPollingPeriod">If the calculation is still running, this operation will be blocked and will not return before this period [ms] expires. If the calculation is completed, it will return immediately.  The default of 0 ms will cause the operation to return immediately in any case. Use a value &gt; 0 to implement long polling to reduce the number of requests. See the [tutorial](https://developer.myptv.com/en/resources/tutorials/general/how-use-asynchronous-requests-ptv-developer-apis) on asynchronous requests for details.  (optional, default to 0)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreasResponse</returns>
        ApiResponse<ReachableAreasResponse> GetReachableAreasWithHttpInfo(Guid? id, int? maximumPollingPeriod = default(int?), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts and creates the areas which can be reached from a waypoint, within given horizons. This type of request is recommended when the &#x60;horizons&#x60; parameter is more than 20 minutes or 25 km.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons.</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[drivingDirection]&#x3D;OUTBOUND&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreasId</returns>
        ReachableAreasId StartAndCreateReachableAreas(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts and creates the areas which can be reached from a waypoint, within given horizons. This type of request is recommended when the &#x60;horizons&#x60; parameter is more than 20 minutes or 25 km.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons.</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[drivingDirection]&#x3D;OUTBOUND&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreasId</returns>
        ApiResponse<ReachableAreasId> StartAndCreateReachableAreasWithHttpInfo(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReachableAreasApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons.</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[drivingDirection]&#x3D;OUTBOUND&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreas</returns>
        System.Threading.Tasks.Task<ReachableAreas> CalculateReachableAreasAsync(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons.</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[drivingDirection]&#x3D;OUTBOUND&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreas)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReachableAreas>> CalculateReachableAreasWithHttpInfoAsync(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of a reachable areas calculation.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteReachableAreasAsync(Guid? id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of a reachable areas calculation.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteReachableAreasWithHttpInfoAsync(Guid? id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable areas calculation specified by its ID.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of a reachable areas calculation.</param>
        /// <param name="maximumPollingPeriod">If the calculation is still running, this operation will be blocked and will not return before this period [ms] expires. If the calculation is completed, it will return immediately.  The default of 0 ms will cause the operation to return immediately in any case. Use a value &gt; 0 to implement long polling to reduce the number of requests. See the [tutorial](https://developer.myptv.com/en/resources/tutorials/general/how-use-asynchronous-requests-ptv-developer-apis) on asynchronous requests for details.  (optional, default to 0)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreasResponse</returns>
        System.Threading.Tasks.Task<ReachableAreasResponse> GetReachableAreasAsync(Guid? id, int? maximumPollingPeriod = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable areas calculation specified by its ID.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of a reachable areas calculation.</param>
        /// <param name="maximumPollingPeriod">If the calculation is still running, this operation will be blocked and will not return before this period [ms] expires. If the calculation is completed, it will return immediately.  The default of 0 ms will cause the operation to return immediately in any case. Use a value &gt; 0 to implement long polling to reduce the number of requests. See the [tutorial](https://developer.myptv.com/en/resources/tutorials/general/how-use-asynchronous-requests-ptv-developer-apis) on asynchronous requests for details.  (optional, default to 0)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreasResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReachableAreasResponse>> GetReachableAreasWithHttpInfoAsync(Guid? id, int? maximumPollingPeriod = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts and creates the areas which can be reached from a waypoint, within given horizons. This type of request is recommended when the &#x60;horizons&#x60; parameter is more than 20 minutes or 25 km.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons.</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[drivingDirection]&#x3D;OUTBOUND&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreasId</returns>
        System.Threading.Tasks.Task<ReachableAreasId> StartAndCreateReachableAreasAsync(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts and creates the areas which can be reached from a waypoint, within given horizons. This type of request is recommended when the &#x60;horizons&#x60; parameter is more than 20 minutes or 25 km.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons.</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[drivingDirection]&#x3D;OUTBOUND&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreasId)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReachableAreasId>> StartAndCreateReachableAreasWithHttpInfoAsync(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReachableAreasApi : IReachableAreasApiSync, IReachableAreasApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ReachableAreasApi : IReachableAreasApi
    {
        private PTV.Developer.Clients.routing.osm.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreasApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ReachableAreasApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreasApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ReachableAreasApi(string basePath)
        {
            this.Configuration = PTV.Developer.Clients.routing.osm.Client.Configuration.MergeConfigurations(
                PTV.Developer.Clients.routing.osm.Client.GlobalConfiguration.Instance,
                new PTV.Developer.Clients.routing.osm.Client.Configuration { BasePath = basePath }
            );
            this.Client = new PTV.Developer.Clients.routing.osm.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new PTV.Developer.Clients.routing.osm.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = PTV.Developer.Clients.routing.osm.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreasApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ReachableAreasApi(PTV.Developer.Clients.routing.osm.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = PTV.Developer.Clients.routing.osm.Client.Configuration.MergeConfigurations(
                PTV.Developer.Clients.routing.osm.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new PTV.Developer.Clients.routing.osm.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new PTV.Developer.Clients.routing.osm.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = PTV.Developer.Clients.routing.osm.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreasApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public ReachableAreasApi(PTV.Developer.Clients.routing.osm.Client.ISynchronousClient client, PTV.Developer.Clients.routing.osm.Client.IAsynchronousClient asyncClient, PTV.Developer.Clients.routing.osm.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = PTV.Developer.Clients.routing.osm.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public PTV.Developer.Clients.routing.osm.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public PTV.Developer.Clients.routing.osm.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public PTV.Developer.Clients.routing.osm.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public PTV.Developer.Clients.routing.osm.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        ///  Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons.</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[drivingDirection]&#x3D;OUTBOUND&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreas</returns>
        public ReachableAreas CalculateReachableAreas(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.osm.Client.ApiResponse<ReachableAreas> localVarResponse = CalculateReachableAreasWithHttpInfo(waypoint, horizons, profile, horizonType, options);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons.</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[drivingDirection]&#x3D;OUTBOUND&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreas</returns>
        public PTV.Developer.Clients.routing.osm.Client.ApiResponse<ReachableAreas> CalculateReachableAreasWithHttpInfo(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0)
        {
            // verify the required parameter 'waypoint' is set
            if (waypoint == null)
            {
                throw new PTV.Developer.Clients.routing.osm.Client.ApiException(400, "Missing required parameter 'waypoint' when calling ReachableAreasApi->CalculateReachableAreas");
            }

            // verify the required parameter 'horizons' is set
            if (horizons == null)
            {
                throw new PTV.Developer.Clients.routing.osm.Client.ApiException(400, "Missing required parameter 'horizons' when calling ReachableAreasApi->CalculateReachableAreas");
            }

            PTV.Developer.Clients.routing.osm.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.osm.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "waypoint", waypoint));
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("csv", "horizons", horizons));
            if (horizonType != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "horizonType", horizonType));
            }
            if (options != null)
            {
                if (options.DrivingDirection != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "options[drivingDirection]", options.DrivingDirection));
                }
            }

            localVarRequestOptions.Operation = "ReachableAreasApi.CalculateReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ReachableAreas>("/reachable-areas", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CalculateReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons.</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[drivingDirection]&#x3D;OUTBOUND&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreas</returns>
        public async System.Threading.Tasks.Task<ReachableAreas> CalculateReachableAreasAsync(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.routing.osm.Client.ApiResponse<ReachableAreas> localVarResponse = await CalculateReachableAreasWithHttpInfoAsync(waypoint, horizons, profile, horizonType, options, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons.</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[drivingDirection]&#x3D;OUTBOUND&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreas)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routing.osm.Client.ApiResponse<ReachableAreas>> CalculateReachableAreasWithHttpInfoAsync(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'waypoint' is set
            if (waypoint == null)
            {
                throw new PTV.Developer.Clients.routing.osm.Client.ApiException(400, "Missing required parameter 'waypoint' when calling ReachableAreasApi->CalculateReachableAreas");
            }

            // verify the required parameter 'horizons' is set
            if (horizons == null)
            {
                throw new PTV.Developer.Clients.routing.osm.Client.ApiException(400, "Missing required parameter 'horizons' when calling ReachableAreasApi->CalculateReachableAreas");
            }


            PTV.Developer.Clients.routing.osm.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.osm.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "waypoint", waypoint));
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("csv", "horizons", horizons));
            if (horizonType != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "horizonType", horizonType));
            }
            if (options != null)
            {
                if (options.DrivingDirection != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "options[drivingDirection]", options.DrivingDirection));
                }
            }

            localVarRequestOptions.Operation = "ReachableAreasApi.CalculateReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ReachableAreas>("/reachable-areas", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CalculateReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of a reachable areas calculation.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void DeleteReachableAreas(Guid? id, int operationIndex = 0)
        {
            DeleteReachableAreasWithHttpInfo(id);
        }

        /// <summary>
        ///  Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of a reachable areas calculation.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public PTV.Developer.Clients.routing.osm.Client.ApiResponse<Object> DeleteReachableAreasWithHttpInfo(Guid? id, int operationIndex = 0)
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new PTV.Developer.Clients.routing.osm.Client.ApiException(400, "Missing required parameter 'id' when calling ReachableAreasApi->DeleteReachableAreas");
            }

            PTV.Developer.Clients.routing.osm.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.osm.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "ReachableAreasApi.DeleteReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/reachable-areas/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of a reachable areas calculation.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteReachableAreasAsync(Guid? id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            await DeleteReachableAreasWithHttpInfoAsync(id, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        ///  Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of a reachable areas calculation.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routing.osm.Client.ApiResponse<Object>> DeleteReachableAreasWithHttpInfoAsync(Guid? id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new PTV.Developer.Clients.routing.osm.Client.ApiException(400, "Missing required parameter 'id' when calling ReachableAreasApi->DeleteReachableAreas");
            }


            PTV.Developer.Clients.routing.osm.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.osm.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "ReachableAreasApi.DeleteReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/reachable-areas/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Gets the results of a reachable areas calculation specified by its ID.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of a reachable areas calculation.</param>
        /// <param name="maximumPollingPeriod">If the calculation is still running, this operation will be blocked and will not return before this period [ms] expires. If the calculation is completed, it will return immediately.  The default of 0 ms will cause the operation to return immediately in any case. Use a value &gt; 0 to implement long polling to reduce the number of requests. See the [tutorial](https://developer.myptv.com/en/resources/tutorials/general/how-use-asynchronous-requests-ptv-developer-apis) on asynchronous requests for details.  (optional, default to 0)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreasResponse</returns>
        public ReachableAreasResponse GetReachableAreas(Guid? id, int? maximumPollingPeriod = default(int?), int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.osm.Client.ApiResponse<ReachableAreasResponse> localVarResponse = GetReachableAreasWithHttpInfo(id, maximumPollingPeriod);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Gets the results of a reachable areas calculation specified by its ID.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of a reachable areas calculation.</param>
        /// <param name="maximumPollingPeriod">If the calculation is still running, this operation will be blocked and will not return before this period [ms] expires. If the calculation is completed, it will return immediately.  The default of 0 ms will cause the operation to return immediately in any case. Use a value &gt; 0 to implement long polling to reduce the number of requests. See the [tutorial](https://developer.myptv.com/en/resources/tutorials/general/how-use-asynchronous-requests-ptv-developer-apis) on asynchronous requests for details.  (optional, default to 0)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreasResponse</returns>
        public PTV.Developer.Clients.routing.osm.Client.ApiResponse<ReachableAreasResponse> GetReachableAreasWithHttpInfo(Guid? id, int? maximumPollingPeriod = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new PTV.Developer.Clients.routing.osm.Client.ApiException(400, "Missing required parameter 'id' when calling ReachableAreasApi->GetReachableAreas");
            }

            PTV.Developer.Clients.routing.osm.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.osm.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (maximumPollingPeriod != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "maximumPollingPeriod", maximumPollingPeriod));
            }

            localVarRequestOptions.Operation = "ReachableAreasApi.GetReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ReachableAreasResponse>("/reachable-areas/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Gets the results of a reachable areas calculation specified by its ID.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of a reachable areas calculation.</param>
        /// <param name="maximumPollingPeriod">If the calculation is still running, this operation will be blocked and will not return before this period [ms] expires. If the calculation is completed, it will return immediately.  The default of 0 ms will cause the operation to return immediately in any case. Use a value &gt; 0 to implement long polling to reduce the number of requests. See the [tutorial](https://developer.myptv.com/en/resources/tutorials/general/how-use-asynchronous-requests-ptv-developer-apis) on asynchronous requests for details.  (optional, default to 0)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreasResponse</returns>
        public async System.Threading.Tasks.Task<ReachableAreasResponse> GetReachableAreasAsync(Guid? id, int? maximumPollingPeriod = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.routing.osm.Client.ApiResponse<ReachableAreasResponse> localVarResponse = await GetReachableAreasWithHttpInfoAsync(id, maximumPollingPeriod, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Gets the results of a reachable areas calculation specified by its ID.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of a reachable areas calculation.</param>
        /// <param name="maximumPollingPeriod">If the calculation is still running, this operation will be blocked and will not return before this period [ms] expires. If the calculation is completed, it will return immediately.  The default of 0 ms will cause the operation to return immediately in any case. Use a value &gt; 0 to implement long polling to reduce the number of requests. See the [tutorial](https://developer.myptv.com/en/resources/tutorials/general/how-use-asynchronous-requests-ptv-developer-apis) on asynchronous requests for details.  (optional, default to 0)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreasResponse)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routing.osm.Client.ApiResponse<ReachableAreasResponse>> GetReachableAreasWithHttpInfoAsync(Guid? id, int? maximumPollingPeriod = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new PTV.Developer.Clients.routing.osm.Client.ApiException(400, "Missing required parameter 'id' when calling ReachableAreasApi->GetReachableAreas");
            }


            PTV.Developer.Clients.routing.osm.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.osm.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (maximumPollingPeriod != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "maximumPollingPeriod", maximumPollingPeriod));
            }

            localVarRequestOptions.Operation = "ReachableAreasApi.GetReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ReachableAreasResponse>("/reachable-areas/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Starts and creates the areas which can be reached from a waypoint, within given horizons. This type of request is recommended when the &#x60;horizons&#x60; parameter is more than 20 minutes or 25 km.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons.</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[drivingDirection]&#x3D;OUTBOUND&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreasId</returns>
        public ReachableAreasId StartAndCreateReachableAreas(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.osm.Client.ApiResponse<ReachableAreasId> localVarResponse = StartAndCreateReachableAreasWithHttpInfo(waypoint, horizons, profile, horizonType, options);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Starts and creates the areas which can be reached from a waypoint, within given horizons. This type of request is recommended when the &#x60;horizons&#x60; parameter is more than 20 minutes or 25 km.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons.</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[drivingDirection]&#x3D;OUTBOUND&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreasId</returns>
        public PTV.Developer.Clients.routing.osm.Client.ApiResponse<ReachableAreasId> StartAndCreateReachableAreasWithHttpInfo(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0)
        {
            // verify the required parameter 'waypoint' is set
            if (waypoint == null)
            {
                throw new PTV.Developer.Clients.routing.osm.Client.ApiException(400, "Missing required parameter 'waypoint' when calling ReachableAreasApi->StartAndCreateReachableAreas");
            }

            // verify the required parameter 'horizons' is set
            if (horizons == null)
            {
                throw new PTV.Developer.Clients.routing.osm.Client.ApiException(400, "Missing required parameter 'horizons' when calling ReachableAreasApi->StartAndCreateReachableAreas");
            }

            PTV.Developer.Clients.routing.osm.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.osm.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "waypoint", waypoint));
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("csv", "horizons", horizons));
            if (horizonType != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "horizonType", horizonType));
            }
            if (options != null)
            {
                if (options.DrivingDirection != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "options[drivingDirection]", options.DrivingDirection));
                }
            }

            localVarRequestOptions.Operation = "ReachableAreasApi.StartAndCreateReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<ReachableAreasId>("/reachable-areas", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("StartAndCreateReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Starts and creates the areas which can be reached from a waypoint, within given horizons. This type of request is recommended when the &#x60;horizons&#x60; parameter is more than 20 minutes or 25 km.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons.</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[drivingDirection]&#x3D;OUTBOUND&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreasId</returns>
        public async System.Threading.Tasks.Task<ReachableAreasId> StartAndCreateReachableAreasAsync(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.routing.osm.Client.ApiResponse<ReachableAreasId> localVarResponse = await StartAndCreateReachableAreasWithHttpInfoAsync(waypoint, horizons, profile, horizonType, options, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Starts and creates the areas which can be reached from a waypoint, within given horizons. This type of request is recommended when the &#x60;horizons&#x60; parameter is more than 20 minutes or 25 km.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons.</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/osm-profiles) such as _EUR_OSM_CAR_. (optional, default to &quot;EUR_OSM_CAR&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[drivingDirection]&#x3D;OUTBOUND&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreasId)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routing.osm.Client.ApiResponse<ReachableAreasId>> StartAndCreateReachableAreasWithHttpInfoAsync(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'waypoint' is set
            if (waypoint == null)
            {
                throw new PTV.Developer.Clients.routing.osm.Client.ApiException(400, "Missing required parameter 'waypoint' when calling ReachableAreasApi->StartAndCreateReachableAreas");
            }

            // verify the required parameter 'horizons' is set
            if (horizons == null)
            {
                throw new PTV.Developer.Clients.routing.osm.Client.ApiException(400, "Missing required parameter 'horizons' when calling ReachableAreasApi->StartAndCreateReachableAreas");
            }


            PTV.Developer.Clients.routing.osm.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.osm.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.osm.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "waypoint", waypoint));
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("csv", "horizons", horizons));
            if (horizonType != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "horizonType", horizonType));
            }
            if (options != null)
            {
                if (options.DrivingDirection != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.osm.Client.ClientUtils.ParameterToMultiMap("", "options[drivingDirection]", options.DrivingDirection));
                }
            }

            localVarRequestOptions.Operation = "ReachableAreasApi.StartAndCreateReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ReachableAreasId>("/reachable-areas", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("StartAndCreateReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
